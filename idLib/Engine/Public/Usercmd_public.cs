/*
===========================================================================

Return to Castle Wolfenstein XNA Managed C# Port
Copyright (c) 2010 JV Software
Copyright (C) 1999-2010 id Software LLC, a ZeniMax Media company. 

This file is part of the Return to Castle Wolfenstein XNA Managed C# Port GPL Source Code.  

RTCW C# Source Code is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RTCW C# Source Code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with RTCW C# Source Code.  If not, see <www.gnu.org/licenses/>.

In addition, the RTCW SP Source Code is also subject to certain additional terms. 
You should have received a copy of these additional terms immediately following the terms 
and conditions of the GNU General Public License which accompanied the RTCW C# Source Code.  
If not, please request a copy in writing from id Software at the address below.

If you have questions concerning this license or the applicable additional terms, you may contact in writing 
id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.

===========================================================================
*/

// Usercmd_public.cs (c) 2010 JV Software
//

using idLib.Game;
using idLib.Engine.Public.Net;

namespace idLib.Engine.Public
{
    //
    // UsercmdButtons
    //
    public enum UsercmdButtons
    {
        //
        // usercmd_t->button bits, many of which are generated by the client system,
        // so they aren't game/cgame only definitions
        //
        BUTTON_ATTACK    =   1,
        BUTTON_TALK      =   2,          // displays talk balloon and disables actions
        BUTTON_USE_HOLDABLE = 4,
        BUTTON_GESTURE   =   8,
        BUTTON_WALKING   =   16,          // walking can't just be infered from MOVE_RUN
										        // because a key pressed late in the frame will
										        // only generate a small move value for that frame
										        // walking will use different animations and
										        // won't generate footsteps
        //----(SA)	added
        BUTTON_SPRINT    =   32,
        BUTTON_ACTIVATE  =   64,
        //----(SA)	end

        BUTTON_ANY       =   128,        // any key whatsoever
    };

    //
    // UsercmdButtonsExtended
    //
    public enum UsercmdButtonsExtended
    {
        //----(SA) wolf buttons
        WBUTTON_ATTACK2   =   1,
        WBUTTON_ZOOM      =   2,
        WBUTTON_QUICKGREN =  4,
        WBUTTON_RELOAD    =  8,
        WBUTTON_LEANLEFT  =  16,
        WBUTTON_LEANRIGHT =  32,

        // unused
        WBUTTON_EXTRA6    =  64,
        WBUTTON_EXTRA7    =  128,
        //----(SA) end

        MOVE_RUN          =  120         // if forwardmove or rightmove are >= MOVE_RUN,
		    					        // then BUTTON_WALKING should be set
    };

    // usercmd_t is sent to the server each client frame
    public struct idUsercmd {
	    private int serverTime;
	    private byte buttons;
	    private byte wbuttons;
	    private WeaponType weapon;
	    private byte holdable;          //----(SA)	added
	    private float[] angles;

        public const int Size = (sizeof(byte) * 8) + (sizeof(float) * 3) + sizeof(int);

	    private sbyte forwardmove, rightmove, upmove;
        private byte wolfkick;       // RF, we should move this over to a wbutton, this is a huge waste of bandwidth

        private short cld;         // NERVE - SMF - send client damage in usercmd instead of as a server command

        //
        // InitCommand
        //
        public void InitCommand(int time)
        {
            angles = new float[3];
            serverTime = time;
            buttons = 0;
            wbuttons = 0;
            weapon = WeaponType.WP_NONE;
        }

        //
        // SetMouseDelta
        //
        public void SetViewAngles(float yaw, float pitch, float roll)
        {
            angles[0] = pitch;
            angles[1] = yaw;
            angles[2] = roll;
        }

        //
        // ClampSbyte
        //
        private sbyte ClampSbyte(int i)
        {
            if (i < -128)
            {
                return -128;
            }
            if (i > 127)
            {
                return 127;
            }
            return (sbyte)i;
        }

        //
        // SetForwardMove
        //
        public void SetMove(int forward, int right, int up)
        {
            forwardmove = ClampSbyte(forward);
            rightmove = ClampSbyte(right);
            upmove = ClampSbyte(up);
        }

        //
        // ForwardMove
        //
        public int ForwardMove
        {
            get
            {
                return forwardmove;
            }
        }

        //
        // RightMove
        //
        public int RightMove
        {
            get
            {
                return rightmove;
            }
        }

        //
        // UpMove
        //
        public int UpMove
        {
            get
            {
                return upmove;
            }
        }

        //
        // pitch
        //
        public float pitch
        {
            get
            {
                return angles[0];
            }
        }

        //
        // yaw
        //
        public float yaw
        {
            get
            {
                return angles[1];
            }
        }

        //
        // roll
        //
        public float roll
        {
            get
            {
                return angles[2];
            }
        }

        //
        // SetCurrentWeapon
        //
        public void SetCurrentWeapon(WeaponType weapon)
        {
            this.weapon = weapon;
        }

        //
        // Weapon
        //
        public WeaponType Weapon
        {
            get
            {
                return weapon;
            }
        }

        //
        // SetButtonDown
        //
        public void SetButtonDown(UsercmdButtons button)
        {
            buttons |= (byte)button;
        }

        //
        // SetButtonDown
        //
        public void SetButtonDown(UsercmdButtonsExtended button)
        {
            wbuttons |= (byte)button;
        }

        //
        // isButtonDown
        //
        public bool isButtonDown(UsercmdButtons button)
        {
            return ((buttons & (byte)button) != 0);
        }

        //
        // isButtonDown
        //
        public bool isButtonDown(UsercmdButtonsExtended button)
        {
            return ((wbuttons & (byte)button) != 0);
        }

        //
        // RemoveButton
        //
        public void RemoveButton(UsercmdButtons button)
        {
            buttons &= (byte)~button;
        }

        //
        // RemoveButton
        //
        public void RemoveButton(UsercmdButtonsExtended button)
        {
            wbuttons &= (byte)~button;
        }

        public void ReadPacket(ref idMsgReader msg)
        {
            serverTime = msg.ReadInt();
            buttons = msg.ReadByte();
            wbuttons = msg.ReadByte();
            weapon = (WeaponType)msg.ReadByte();
            holdable = msg.ReadByte();

            angles[0] = msg.ReadFloat();
            angles[1] = msg.ReadFloat();
            angles[2] = msg.ReadFloat();

            forwardmove = msg.ReadSByte();
            rightmove = msg.ReadSByte();
            upmove = msg.ReadSByte();

            cld = msg.ReadShort();
        }

        public void WritePacket(ref idMsgWriter msg)
        {
            msg.WriteInt(serverTime);
            msg.WriteByte(buttons);
            msg.WriteByte(wbuttons);
            msg.WriteByte((byte)weapon);
            msg.WriteByte(holdable);

            msg.WriteFloat(angles[0]);
            msg.WriteFloat(angles[1]);
            msg.WriteFloat(angles[2]);

            msg.WriteSbyte(forwardmove);
            msg.WriteSbyte(rightmove);
            msg.WriteSbyte(upmove);

            msg.WriteShort(cld);
        }
    };

    //
    // idUsercmdManager
    //
    public abstract class idUsercmdManager
    {
        public abstract void Init();

        public abstract void MouseEvent(int x, int y);
        public abstract void KeyEvent(byte key, bool down);

        public abstract idUsercmd GetCurrentCommand();
    }
}
